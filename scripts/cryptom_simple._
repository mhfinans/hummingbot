from decimal import Decimal
from typing import List

from hummingbot.connector.exchange_base import ExchangeBase
from hummingbot.core.data_type.common import OrderType, TradeType
from hummingbot.core.data_type.order_candidate import OrderCandidate
from hummingbot.strategy.script_strategy_base import ScriptStrategyBase
import redis
from typing import Any, Dict, List, Set
from hummingbot.client.settings import ConnectorSetting
import json
import logging
import os

class Cryptom(ScriptStrategyBase):
    config = {
        "bid_spread": "0.1",
        "ask_spread": "0.1",
        "front_market": "cryptom",
        "back_market": "binance",
        "pair": "BTC-USDT"
    }
    def __init__(self,connectors: Dict[str, ConnectorSetting]):
        super().__init__(connectors)
        self.getParamsFromEnv()
        self.initRedisClient()
    
    markets = {config["front_market"]: {config["pair"]}, config["back_market"]: {config["pair"]}}

    @property
    def front_connector(self) -> ExchangeBase:
        return self.connectors[self.config["front_market"]]

    @property
    def back_connector(self) -> ExchangeBase:
        return self.connectors[self.config["back_market"]]    
    

    def on_tick(self):
        self.pop_config()
        logging.getLogger(__name__).debug("config {}".format(self.config))
        self.perform()
        self.push_status()
        
    def createOrdersInBack(self):
        front_active_orders = self.get_active_orders(self.config["front_market"])
        back_active_orders = self.get_active_orders(self.config["back_market"])
        for order in front_active_orders:
            if order.order_type == OrderType.Buy:
                if not self.DoesExistOrderInBackMarket(order.order_id):
                    self.createBuyOrderInBackMarket()

    def DoesExistOrderInBackMarket(self, order_id: str):
        
    
    def createBuyOrderInBackMarket(self):
        order = self.create_buy_order()
        self.back_connector.place_order(order)
        
            
    def create_buy_order(self, is_bid: bool) -> OrderCandidate:
        mid_price = Decimal(self.adjusted_mid_price())
        bid_spread = Decimal(self.strategy["bid_spread"])
        ask_spread = Decimal(self.strategy["ask_spread"])
        bid_price = mid_price - mid_price * bid_spread * Decimal(.01)
        ask_price = mid_price + mid_price * ask_spread * Decimal(.01)
        price = bid_price if is_bid else ask_price
        price = self.connector.quantize_order_price(self.strategy["pair"], Decimal(price))
        order = OrderCandidate(
            trading_pair=self.strategy["pair"],
            is_maker=False,
            order_type=OrderType.LIMIT,
            order_side=TradeType.BUY if is_bid else TradeType.SELL,
            amount=Decimal(self.strategy["amount"]),
            price=price)
        return order

    def adjusted_mid_price(self):
        """
        Returns the  price of a hypothetical buy and sell or the base asset where the amout is {strategy.test_volume}
        """
        ask_result = self.connector.get_quote_volume_for_base_amount(self.strategy["pair"], True, self.strategy["test_volume"])
        bid_result = self.connector.get_quote_volume_for_base_amount(self.strategy["pair"], False, self.strategy["test_volume"])
        average_ask = ask_result.result_volume / ask_result.query_volume
        average_bid = bid_result = bid_result.result_volume / bid_result.query_volume
        return average_bid + ((average_ask - average_bid) / 2)

    def format_status(self) -> str:
        """
        Returns status of the current strategy on user balances and current active orders. This function is called
        when status command is issued. Override this function to create custom status display output.
        """
        if not self.ready_to_trade:
            return "Market connectors are not ready."
        lines = []
        warning_lines = []
        warning_lines.extend(self.network_warning(self.get_market_trading_pair_tuples()))
        actual_mid_price = self.connector.get_mid_price(self.strategy["pair"])
        adjusted_mid_price = self.adjusted_mid_price()
        lines.extend(["", "  Adjusted mid price: " + str(adjusted_mid_price)] + ["  Actual mid price: " + str(actual_mid_price)])
        balance_df = self.get_balance_df()
        lines.extend(["", "  Balances:"] + ["    " + line for line in balance_df.to_string(index=False).split("\n")])
        try:
            df = self.active_orders_df()
            lines.extend(["", "  Orders:"] + ["    " + line for line in df.to_string(index=False).split("\n")])
        except ValueError:
            lines.extend(["", "  No active maker orders."])

        warning_lines.extend(self.balance_warning(self.get_market_trading_pair_tuples()))
        if len(warning_lines) > 0:
            lines.extend(["", "*** WARNINGS ***"] + warning_lines)
        return "\n".join(lines)
    
    def getParamsFromEnv(self):
        self.REDIS_URL=os.getenv("REDIS_URL", "redis://localhost:6379/0")
        self.TASK_ID=os.getenv("TASK_ID","task_id")

    def initRedisClient(self):
        self.redis_client = redis.Redis.from_url(self.REDIS_URL)
        if self.redis_client is None:
            logging.getLogger(__name__).error("Redis client is None")
    
    def push_status(self):
        try:
            self.redis_client.set(self.TASK_ID+"_status", json.dumps(self.status))
        except Exception as e:
            logging.getLogger(__name__).error("Error pushing task object to redis: {0}".format(e))
            return False
    
    def pop_config(self):
        try:
            json_str=self.redis_client.get(self.TASK_ID+"_config").decode("utf-8")
            if json is not None:
                self.config=json.loads(json_str)
                logging.getLogger(__name__).info("config: {0}".format(self.config))
           
        except Exception as e:
            logging.getLogger(__name__).error("Error pop task object to redis: {0}".format(e))
            return False        
